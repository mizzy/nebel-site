---
layout: post
title: "Catalystでajax (HTML::Prototypeモジュールの使い方)"
date: 2005-09-10 17:52
comments: true
categories: 
---
<h3>changelog</h3>
<p class="entryBody">
<ul class="entryBody">
<li>typoを修正。positionの説明で「4通り」を「44通り」と書いていたので。そんなにあるわけない。(2005/05/13)</li>
<li><a href="#form_remote_tag">$prototype->form_remote_tag</a>のオプションpostitionの説明を追加。(2005/04/30)</li>
</ul>

<h3>概要</h3>
<p class="entryBody">
<a href="http://antipop.zapto.org/mt/archives/001280.php" target="_blank">Catalyst で作る簡単 Web アプリケーション: Feed2JS 解説</a>を参考にしながら、<a href="http://catalyst.perl.org/" target="_blank">Catalyst</a>をいじっていたのですが、ajaxな部分を司る<a href="http://search.cpan.org/dist/Catalyst-Plugin-Prototype/lib/Catalyst/Plugin/Prototype.pm" target="_blank">Catalyst::Plugin::Prototype</a>について調べたことを、ここにメモしておきます。
</p>

<p class="entryBody">
まず、「prototype」という名が示すのは、「原型」という意味ではなくて、<a href="http://prototype.conio.net/" target="_blank">prototypeという名のオブジェクト指向Javascriptライブラリ</a>です。俺は最初それが分からず、「ん？何かの原型を作るようなモジュールなのか？」と悩んでました。このライブラリの実態はこんな感じです。<a href="http://prototype.conio.net/dist/prototype-1.2.0.js" target="_blank">prototype.js</a>
</p>

<p class="entryBody">
で、Catalyst::Plugin::Prototype自体は、<a href="http://search.cpan.org/~sri/HTML-Prototype/Prototype.pm" target="_blank">HTML::Prototype</a>のメソッドをCatalystのビューから呼び出せる様にするものです。なので、Catalyst::Plugin::Prototypeの使い方を知るためには、まずはHTML::Prototypeの使い方を知る必要があります。
</p>


<p class="entryBody">
このHTML::Protoytypeは何をするものなのかというと、prototype.js内のajax関連の関数を呼び出すようなHTMLを手軽に生成するためのもの、ということになります。以下、HTML::Prototypeの使い方と、Catalystから呼び出す方法についてHTML::Prototypeのドキュメントを参考にしながら、実行例も交えて順に見ていきます。また、ドキュメントに載っていないものの、ソースコードから読みとれるものもできる限り記述したいと思います。
</p>

<p class="entryBody">
基本的なHTML::Prototypeの使い方は以下の様になります。
</p>

<pre class="code">
use HTML::Prototype;

my $prototype = HTML::Prototype->new;
print $prototype->define_javascript_functions;
</pre>

<p class="entryBody">
HTML::Prototypeで利用できるメソッドは以下の通りです。
</p>

<ul class="entryBody">
<li><a href="#define_javascript_functions">$prototype->define_javascript_functions</a></li>
<li><a href="#form_remote_tag">$prototype->form_remote_tag(\%option)</a></li>
<li><a href="#link_to_function">$prototype->link_to_function( $name, $function )</a></li>
<li><a href="#link_to_remote">$prototype->link_to_remote( $id, \%options )</a></li>
<li><a href="#observe_field">$prototype->observe_field( $id, \%options)</a></li>
<li><a href="#observe_form">$prototype->observe_form( $id, \%options )</a></li>
<li><a href="#periodically_call_remote">$prototype->periodically_call_remote( \%options )</a></li>
<li><a href="#submit_to_remote">$prototype->submit_to_remote( $name, $value, \%options )</a></li>
</ul>

<p class="entryBody">
各メソッドを順に見ていきます。
</p>

<h3><a id="define_javascript_functions">$prototype->define_javascript_functions</a></h3>

<p class="entryBody">
このメソッドはprototype.jsの内容そのものを返します。つまり、
</p>

<pre class="code">
print $prototype->define_javascript_functions;
</pre>

<p class="entryBody">
を実行すると、以下の内容が出力されます。
</p>

<pre class="code">
&lt;script type="text/javascript"&gt;
&lt;!--
/*  Prototype: an object-oriented Javascript library, version 1.2.0
 *  (c) 2005 Sam Stephenson &lt;sam@conio.net&gt;
 *
 *  THIS FILE IS AUTOMATICALLY GENERATED. When sending patches, please diff
 *  against the source tree, available from the Prototype darcs repository.
 *
 *  Prototype is freely distributable under the terms of an MIT-style license.
 *
 *  For details, see the Prototype web site: http://prototype.conio.net/
 *
/*--------------------------------------------------------------------------*/

var Prototype = {
  Version: '1.2.0'
}
... (省略)
</pre>

<p class="entryBody">
これはあんまり使い道ない気がします。HTML内で、
</p>

<pre class="code">
&lt;script type="text/javascript" src="prototype.js"&gt;&lt;/script&gt;
</pre>

<p class="entryBody">
としてやればいいですし、Catalystでも、
</p>

<pre class="code">
$ script/my-app_create.pl Prototype
</pre>

<p class="entryBody">
でroot以下にprototype.jsが生成されますから。
</p>


<h3><a id="form_remote_tag">$prototype->form_remote_tag(\%option)</a></h3>

<p class="entryBody">
このメソッドでは、xmlHttpRequestでサブミットする様なformタグを生成します。オプションとその説明は以下の通りです。
</p>

<pre class="code">
$prototype->form_remote_tag({
    <strong>method</strong> => 'post',
    <strong>url</strong> => '/url',
    <strong>update</strong> => 'id',
    <strong>position</strong> => 'Before',
    <strong>type</strong> => 'synchronous',
    <strong>callback</strong> => 'callback()',
});
</pre>

<dl class="entryBody">
<dt>method</dt>
<dd>リクエストメソッドを指定します。</dd>
<dt>url</dt>
<dd>submit先のURLを指定します。</dd>
<dt>update</dt>
<dd>
xmlHttpRequestで得られたレスポンスを、どのidを持つコンテナに挿入するかを指定します。つまり、ここで指定したidに対して、prototype.jsが document.getElementById(id).innerHTML = req.responseText; みたいなことをやってくれます。
</dd>
<dt>position</dt>
<dd>
何も指定しない場合、idで指定されたコンテナの内容をすべてresponseTextで置き換えますが、positionを指定していると、特定の位置にreponseTextを挿入します。指定できる位置は以下の4通りです。
<ul>
<li>Before ... コンテナの直前。（コンテナの外側）</li>
<li>Top ... コンテナの一番上。（コンテナの内側）</li>
<li>Bottom ... コンテナの一番下。（コンテナの内側）</li>
<li>After ... コンテナの直後。（コンテナの外側）</li>
</ul>
</dd>
<dt>type</dt>
<dd>synchronousかasynchronousを指定します。デフォルトはasynchronousです。</dd>
<dt>callback</dt>
<dd>
xmlHttpRequestのreadyStateに応じて呼び出す関数を指定します。callbackには以下の種類があります。
<ul>
<li>loading ... readyStateが1の時に呼び出す関数を指定します。</li>
<li>loaded ... readyStateが2の時に呼び出す関数を指定します。</li>
<li>interactive ... readyStateが3の時に呼び出す関数を指定します。</li>
<li>complete ... readyStateが4の時に呼び出す関数を指定します。</li>
</ul>
</dd>
</dl>

<p class="entryBody">
実際にこのメソッドが吐き出すHTMLコードを見るために、
</p>

<pre class="code">
print $prototype->form_remote_tag({
    url => '/url',
    update => 'id',
    type => 'synchronous',
    loading => 'loading()',
});
</pre>

<p class="entryBody">
というコードを実行してみると、以下の様に出力されます。
</p>

<pre class="code">
&lt;form onsubmit=" new Ajax.Updater( 'id',  '/url', { parameters: Form.serialize(this),asynchronous: 0,onLoading: function(request){loading()} } ) ; return false;"&gt;
</pre>

<h3><a id="link_to_function">$prototype->link_to_function( $name, $function )</a></h3>

<p class="entryBody">
このメソッドでは、$functionを呼び出す、$nameで指定したアンカーを持つリンクを生成します。実行すれば一目瞭然、ってことで、
</p>

<pre class="code">
print $prototype->link_to_function( "<strong>Greeting</strong>", "<strong>alert('Hello World!')</strong>" );
</pre>

<p class="entryBody">
と実行すると、
</p>

<pre class="code">
&lt;a href="#" onClick="<strong>alert('Hello World!');</strong> return false;"&gt;<strong>Greeting</strong>&lt;/a&gt;
</pre>

<p class="entryBody">
というHTMLを吐きますし、
</p>

<pre class="code">
print $prototype->link_to_function( '<strong>&lt;img src="really.png"/&gt;</strong>', '<strong>do_delete()</strong>' );
</pre>

<p class="entryBody">
と実行すると、
</p>

<pre class="code">
&lt;a href="#" onClick="<strong>do_delete();</strong> return false;"&gt;<strong>&lt;img src="really.png"/&gt;</strong>&lt;/a&gt;
</pre>

<p class="entryBody">
というHTMLを吐きます。
</p>

<h3><a id="link_to_remote">$prototype->link_to_remote( $id, \%options )</a></h3>

<p class="entryBody">
このメソッドでは、指定したURLに対してxmlHttpRequestでリクエストする様なリンクを返します。オプションと説明は以下の通りです。
</p>

<pre class="code">
$prototype->link_to_remote( 
	<strong>'anchor'</strong>, {
	        <strong>with</strong> => 'name=value',
		url    => 'url',
		update => 'id',
		type => 'synchronous',
		callback => 'callback()',
	})
</pre>

<dl>
<dt>anchor</dt>
<dd>リンクのanchorを指定します。</dd>
<dt>with</dt>
<dd>GETのQUERY_STRINGまたはPOSTのbodyとして送信するデータを、name=valueといった形で指定します。</dd>
<dt>その他のオプション</dt>
<dd>$prototype->form_remote_tag(\%options)と同じです。</dd>
</dl>

<p class="entryBody">
実際にこのメソッドが吐き出すHTMLコードを見るために、
</p>

<pre class="code">
print $prototype->link_to_remote( 
				  'anchor', 
				  {
				      update => 'id',
				      url    => 'url',
				      type => 'synchronous',
				  } );
</pre>

<p class="entryBody">
というコードをを実行すると、
</p>

<pre class="code">
&lt;a href="#" onClick=" new Ajax.Updater( 'id',  'url', { asynchronous: 0 } ) ; return false;"&gt;anchor&lt;/a&gt;
</pre>

<p class="entryBody">
というHTMLを吐きます。
</p>

<h3><a id="observe_field">$prototype->observe_field( $id, \%options)</a></h3>

<p class="entryBody">
このメソッドでは、$idで指定されたidを持つフィールドを監視して、変更があればxmlHttpRequestでリクエストを出すようなスクリプトを返します。%optionsは$prototype->form_remote_tag(\%options)と同じです。
</p>

<p class="entryBody">
実際にこのメソッドが吐き出すJavascriptコードを見るために、
</p>

<pre class="code">
print $prototype->observe_field( 
				  'field_id', 
				  {
				      update => 'id',
				      url    => 'url',
				      type => 'synchronous',
				  } );
</pre>

<p class="entryBody">
と実行すると、
</p>

<pre class="code">
&lt;script type="text/javascript"&gt;
&lt;!--
new Form.Element.Observer( 'field_id', 2, function( element, value ) {  new Ajax.Updater( 'id',  'url', { parameters: value,asynchronous: 0 } )  } );
//--&gt;
&lt;/script&gt;
</pre>

<p class="entryBody">
というJavascriptコードを吐きます。
</p>


<h3><a id="observe_form">$prototype->observe_form( $id, \%options )</a></h3>

<p class="entryBody">
$prototype->observe_fieldと基本的に同じですが、$idで指定されたフォーム全体を監視して、変更があればxmlHttpRequestでリクエストを出すようなスクリプトを返します。%optionsは$prototype->form_remote_tag(\%options)や他と同じです。
</p>

<p class="entryBody">
実際にこのメソッドが吐き出すJavscriptコードを見るために、
</p>

<pre class="code">
print $prototype->observe_form( 
			'form_id', 
			{
				update => 'id',
				url    => 'url',
			});
</pre>

<p class="entryBody">
と実行すると、
</p>

<pre class="code">
&lt;script type="text/javascript"&gt;
&lt;!--
new Form.Observer( 'form_id', 2, function( element, value ) {  new Ajax.Updater( 'id',  'url', { parameters: value,asynchronous: 1 } )  } );
//--&gt;
&lt;/script&gt;
</pre>

<p class="entryBody">
というJavascriptコードを吐きます。
</p>

<h3><a id="periodically_call_remote">$prototype->periodically_call_remote( \%options )</a></h3>

<p class="entryBody">
このメソッドでは、xmlHttpRequestによるサーバへのリクエストを、一定間隔で呼び出すようなスクリプトを返します。$options->{frequency}で時間を秒間隔で指定します。（デフォルト2秒。）他のオプションについては、他のメソッドと同様です。
</p>

<pre class="code">
print $prototype->periodically_call_remote({
				      update => 'id',
				      url    => 'url',
				  });
</pre>

<p class="entryBody">
と実行すると、
</p>

<pre class="code">
&lt;script type="text/javascript"&gt;
&lt;!--
new PeriodicalExecuter( function () {  new Ajax.Updater( 'id',  'url', { asynchr
onous: 1 } )  }, 10 );
//--&gt;
&lt;/script&gt;
</pre>

<p class="entryBody">
というJavascriptコードを吐きます。
</p>

<h3><a id="submit_to_remote">$prototype->submit_to_remote( $name, $value, \%options )</a></h3>

<p class="entryBody">
このメソッドでは、$name, $valueで指定されたnameとvalueをxmlHttpRequestでsubmitするボタンを生成します。%optionsは他のメソッドと同様です。
</p>

<p class="entryBody">
実際にこのメソッドが吐き出すHTMLコードを見るために、
</p>

<pre class="code">
print $prototype->submit_to_remote(
				   'name',
				   'value',
				   {
				       update => 'id',
				       url    => 'url',
				   });
</pre>

<p class="entryBody">
と実行すると、
</p>

<pre class="code">
&lt;input type="button" name="name" value="value" onsubmit=" new Ajax.Updater( 'id',  'url', { asynchronous: 1 } ) ; return false;"/&gt;
</pre>

<p class="entryBody">
というHTMLコードを吐きます。
</p>

<h3>Catalystのビューから呼び出す方法</h3>
<p class="entryBody">
HTML::Prototypeのメソッドを、Catalystのビューから呼び出すためには、テンプレートに以下の様に記述します。</p>

<pre class="code">
&#x5b;% c.prototype.observe_field( 'editor', {
        url    => 'url',
        with   => "'body='+value",
        update => 'view'
    }) %&#x5d;
</pre>

<p class="entryBody">
ご覧頂くと分かるように、オプションの渡し方は、perlでのメソッド呼び出しと何ら変わりありませんので、詳細は省きます。（手抜きですんません。HTML::Prototypeの説明で力尽きました。）
</p>